http://www.lewuxian.com/?author=23040&paged=4
http://www.ituring.com.cn/article/47692
* UniqSearchTree
Lefts X rights combination should have l*r nodes. However, when I first wrote this solution, i generate only |lefts| nodes, make the next right node override the first one.
* SimplifyPath
Last element might not be /
array out of bounds
* BestTimeToBuyAndSellStock3
1) combine left to right scan and  right to left scan
2) verify the single order result
* ValidPalindrome
1) take care of alphanumeric
2) left-to-right as well as right-to-left at the same time, take care of the edge
3) when right and left curser meet, take care of how they meet, especially the case that update left but not update right

* Inorder and Postorder tree
1) border
2) equal array size(in inorder and postorder, so no need to recalculate)

* 3Sum
1) duplicate
 1.1 try skip dest: when -2, 1, 1 occur
 1.2 not skip: 0, 0, 0
 1.3 FINAL solution: use the right-most as target, ignore the left. {-1,0,1} is a subarray of {-1,0,1,1}, so never use {-1,0,1}
2) heap sort in static place
 if use increasing order, make a big heap and substibute the top with the last until it is the only element.

* Add Binary
Do not change the border variable when iteration. use another var.( we have len, not let --len, use "i = len; for(...;; --i)"

* Candy
1) duplicate can be deemed as inc/dec order
2) variables must have understandable meaning

* Polish Notation
remember the stack and the order of opand1 and opand2
